1.对

2.没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用。
箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变；

3.let var const 

4.

5.React 为提高性能，有自己的一套事件处理机制，相当于将事件代理到全局进行处理，也就是说监听函数并未绑定到DOM元素上。因此，如果你禁止react事件冒泡e.stopPropagation()，你就无法阻止原生事件冒泡；你禁用原生事件冒泡e.nativeEvent.stopPropagation()，React的监听函数就调用不到了。
正确的做法是应该是判断event.target对象，是否是目标对象、或包含的对象、或被包含的对象，来决定是否触发事件

6.es6模块的特点：

静态化，必须在顶部，不能使用条件语句，自动采用严格模式
treeshaking和编译优化，以及webpack3中的作用域提升
外部可以拿到实时值，而非缓存值(是引用而不是copy)
es6模块和commonjs模块的区别：

可以对commonjs模块重新赋值，对es6模块重新赋值会编译报错
commonjs是对模块的拷贝（浅拷贝），es6是对模块的引用（也就是说，es6模块只存只读，不能改变其值，具体点就是指针指向不能变，类似const）
es6模块和commonjs模块的相同点：

两者都可以对对象内部属性的值进行改变

7.父子props，子父回调函数，深层子组件ChildrenTypes,子子redux
8.
