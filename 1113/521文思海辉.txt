1.script标签中的defer属性是下载完成就执行，而async是渲染完再执行，多个脚本情况下，defer可以保证加载顺序，这样的说法对吗
1.对

2..call、bind方法是否可以改变箭头函数的this指向？
没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用。
箭头函数在定义之后，this 就不会发生改变了，无论用什么样的方式调用它，this 都不会改变；

3.let、var和const的区别？
   let  是块级作用域，作用域范围更小，一个for 循环也是一个作用域，
  var 是函数作用区，可以重复声明，存在变量的提升
   const 是块级作用域， 是声明常量的，如果是引用类型的常量，是可以改变的，
   如果是基本类型的常量是不可以改变的
 
4.webpack打包最基本的实现方式 是将所有的模块代码放到一个数组里 通过数组ID来引用不同的模块、对吗     对

5.react中如何阻止js原生事件的冒泡？
React 为提高性能，有自己的一套事件处理机制，相当于将事件代理到全局进行处理，也就是说监听函数并未绑定到DOM元素上。因此，如果你禁止react事件冒泡e.stopPropagation()，你就无法阻止原生事件冒泡；你禁用原生事件冒泡e.nativeEvent.stopPropagation()，React的监听函数就调用不到了。
正确的做法是应该是判断event.target对象，是否是目标对象、或包含的对象、或被包含的对象，来决定是否触发事件

6.commonJs的模块可以理解为值的引用，es6的模块可以理解为值的拷贝，是吗？
不对 说反了
es6模块的特点：
  静态化，必须在顶部，不能使用条件语句，自动采用严格模式
  treeshaking和编译优化，以及webpack3中的作用域提升
  外部可以拿到实时值，而非缓存值(是引用而不是copy)
es6模块和commonjs模块的区别：
  可以对commonjs模块重新赋值，对es6模块重新赋值会编译报错
  commonjs是对模块的拷贝（浅拷贝），es6是对模块的引用（也就是说，  es6模块只存只读，不能改变其值，具体点就是指针指向不能变，类似  const）
es6模块和commonjs模块的相同点：
   两者都可以对对象内部属性的值进行改变

7..react组件传值。
React 中组件的几种通信方式，分别是：
   1. 通过props属性实现组件间通信
   父组件向子组件通信：使用 props -->不要超过三层
   子组件向父组件通信：使用 props 回调-->不要超过三层
   2.通过prop-types的context实现跨级组件间通信
    跨级组件间通信双向：使用 context 对象，APP组件和其他所有子孙通信，不太适合组件间通信（可以实现，不好维护）

  3.使用事件订阅实现非嵌套组件间通信，也可以实现跨级组件间通信
  (1)安装 cnpm i events -S
  (2)新建一个文件 ev.js
  (3)A组件 绑定自定义事件，在B触发，回调带回数据

  4.reudx解决复杂应用中组件通信问题

8.了解dva吗？
   dva开发框架:
   ---react-router、redux、redux-saga二次封装
      --代码量变少
      --开发和维护更加方便
   ---webpack脚手架--roadhog
   ---内置redux-devtools-extension
